# 第四部分：软硬件接口设计

## 软件接收以太网帧

到这个时候，CPU 基本功能应该已经完成，可以运行代码并往串口打印一些内容。你需要设计一个接口，使得软件可以读取路由器交由 CPU 处理的以太网帧。常见的方案有：

1. 类似串口，寄存器读一次就读一字节，额外添加状态和长度寄存器。
2. 提供一块缓冲区，给定地址和长度，然后轮询。
3. 提供一系列的缓冲区，软件和硬件分别在一个循环列表的头和尾进行操作。

路由器部分需要按照 Dst IP 决定是否需要转给 CPU，常见的就是 RIP 协议（你也可以选择把 RIP 协议放在硬件里实现）。在 CPU 上进行轮询，不断读取收到的数据，通过串口读出来。这一过程中需要把 C 代码编译为 Bare Metal 的汇编，需要配合 linker script 、汇编和若干编译选项进行。

过程中可能会发现 CPU 实现的若干 BUG，或者遇到没有实现的新指令。前者一般可以通过仔细阅读代码找到，后者可以通过修改编译选项解决。

!!! question

    1. 为什么需要一段引导汇编？
    2. 为什么需要 linker script？

## 路由器的维护和转发表的更新

在这里，我们区分了路由表和转发表：路由表在软件，转发表在硬件，后者是前者的子集，针对硬件查询而优化。你需要实现一种方法，使得软件可以写（读可选）硬件的转发表，当软件的路由表在更新的时候（比如 RIP 协议的处理过程中），通过这种方法下发到硬件的转发表中。如果实现了读取，就可以通过读出来的数据判断是否正确写入了。如果转发表是基于 RAM 的存储，可以直接给 CPU 提供读取 RAM 的方法，这样就可以比较简单地让 CPU 控制转发表。

如果想要进行无缝的转发表更新，可以实现两份的转发表然后进行原子性的交换；或者在 FSM 的实现上保证不会出现死状态的问题，就可以在牺牲一次转发正确性的情况下解决这个问题。

路由表相比于转发表，主要多了路由协议相关的字段，如 metric。在写入转发表的时候，硬件并不需要这些信息。

## RIP 协议实现

首先照着路由器 -> CPU 的方法实现 CPU -> 路由器的功能，让软件可以发送任意以太网帧。

然后就可以实现一个基本的 RIP 协议，通过软硬件接口进行 RIP 包的收发和路由表的下发。建议参考软件实验的 README 中相关内容。
